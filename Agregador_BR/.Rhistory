## The line below might seem strange, but it doesn't make sense to keep
## monthly observations of Q for months that have been dropped
## this is specially a problem for transition between presidents
xx$drop.wcalcQ[is.element(xx$M,months.to.drop)] <- T
cat('Should drop WCALC estimates for the following months:\n')
print(months.to.drop)
cat('and quarters:\n')
print(quarters.do.drop)
return(xx)
}
obsM <- function(d){nrow(d)}
institutesM <- function(d){length(unique(d$Institute))}
instituteM <- function(d){if(length(unique(d$Institute))==1){
as.character(d$Institute[1])}else{"_Multiple"}}
my.averageM <- function(x,drop.series=NULL){
if(is.null(drop.series)==F){	x <- subset(x,Institute!=drop.series)}
tmp <- ddply(x, "M", c("popM","obsM","institutesM"))
tmp2 <- ddply(x, "M", c("instituteM","presUsed"))
out <- merge(tmp,tmp2,by="M",all=T)
return(out)
}
popM <- function(d){#simple aggreagation
ifelse(is.nan(mean(d$Positive,na.rm=T)),NA,mean(d$Positive,na.rm=T))}
popM <- function(x){#for when there is more than one president in the same term
if(length(unique(x$PresidentS))==1){
ifelse(is.nan(mean(x$Positive,na.rm=T)),NA,mean(x$Positive,na.rm=T))
}else{#if more than one president, use incoming
to.keep <- which(x$PresidentS==x$PresidentS[nrow(x)])
ifelse(is.nan(mean(x$Positive[to.keep],na.rm=T)),NA,mean(x$Positive[to.keep],na.rm=T))
}}
presUsed <- function(d){if(length(unique(d$PresidentS))==1){#use incoming president
as.character(d$PresidentS[1])}else{as.character(d$PresidentS[nrow(d)])}}
dateUsed <- function(d){ #if no observation, use start of quarter,
if(is.na(max(d$date))){
out <- gsub("-1","-02-15",d$Q)
out <- gsub("-2","-05-15",out)
out <- gsub("-3","-08-15",out)
out <- gsub("-4","-11-15",out)
}else{
out <- max(d$date)
}
return(out)}
dateUsed <- function(d){max(d$date)}
my.averageQ <- function(x,drop.series=NULL){
if(is.null(drop.series)==F){	x <- subset(x,Institute!=drop.series)}
tmp <- ddply(x, "Q", c("popM",
"obsM","institutesM"))
tmp2 <- ddply(x, "Q", c("instituteM","presUsed"))
tmp3 <- ddply(x, "Q", c("dateUsed"))
out <- merge(merge(tmp,tmp2,by="Q",all=T),tmp3,by="Q",all=T)
names(out)<-gsub("M","Q",names(out))
return(out)
}
#### Merge estimates into d dataset for plotting ####
Ms <- expand.grid(1980:2017,sprintf("%02.0f", 1:12))
Ms <- sort(paste(Ms[,1],Ms[,2],sep="-"))
Qs <- gsub("-01|-02|-03","-1"
,gsub("-04|-05|-06","-2"
,gsub("-07|-08|-09","-3"
,gsub("-10|-11|-12","-4",Ms))))
MQ <- data.frame(M=Ms,Q=Qs)
m1 <- 365/12
#Importing raw data
d <- read_csv("DATA/Popularity-LatinAmerica-BR.csv")
#Or read from saved as windows csv, so read with latin1. If saving as (mac) csv, read with macroman
#d<-read.csv(paste("./DATA/_popularity_BR_25mar21.csv",sep=""),
#            fileEncoding="latin1",na.strings = ".")
dd <- subset(d, President != "Figueiredo")
Nall <- nrow(dd)
#Get rid of spaces in pollster names
d$Institute <- gsub("\\s","\\.",d$Institute,perl=T)
#Use short presidential names, and rder factors cronologically
d$PresidentS <- factor(toupper(d$President),levels=c("FIGUEIREDO","SARNEY","COLLOR",
"FRANCO","CARDOSO","LULA","DILMA"
,"TEMER","BOLSONARO"))
#Check for missing data in relevant vars
tmp <- apply(is.na(subset(d,select=c(raw.date,President,PresidentS,Positive,Institute))),2,sum)
if(sum(tmp)>0){cat("Attention! Data missing in source\n");print(tmp)}
#Fix dates #
#Always a problem in Xls/csv
d$day[which(is.na(d$day))]<-15
d$month <- gsub("ago","aug",d$month)
d$month <- gsub("mai","may",d$month)
d$date <- as.Date(paste(d$year,d$month,d$day,sep="-"),format="%Y-%b-%d")
d$month <- d$day <-  NULL
d<-d[sort(as.character(d$date),index.return=TRUE)$ix,] #sort by date
d$Q <- paste(substr(d$date,1,5),quarters(d$date),sep="") #quarter indicator
d$Q <- gsub("Q","",d$Q)
d$M <- substr(d$date,1,7)#month indicator
d$raw.date <- NULL
save(d, file="R/popularity_raw_BR.RData")
#fork: save Bolsonaro's popularity separately
dd <- subset(d,President=="Bolsonaro"&year>=2019)
save(dd,file="R/popularity_raw_bolsonaro_BR.RData")
load("R/popularity_raw_BR.RData")
### The simple averaging approach ##################
ms <- my.averageM(d)  #by month
qs <- my.averageQ(d)  #by quarter
d$Institute <- gsub("IPEC-ExIBOPE","IBOPE",
gsub("Ibope","IBOPE",d$Institute))#IPEC is former IBOPE
d$Varname <-  gsub("\\s","",ds$Institute)
load("R/popularity_raw_BR.RData")
### The simple averaging approach ##################
ms <- my.averageM(d)  #by month
qs <- my.averageQ(d)  #by quarter
d$Institute <- gsub("IPEC-ExIBOPE","IBOPE",
gsub("Ibope","IBOPE",d$Institute))#IPEC is former IBOPE
d$Varname <-  gsub("\\s","",d$Institute)
d$Date <- d$date
d$Index <- d$Positive
View(d)
ds <- d #prepare data from stimsons' wcalc
ds$Institute <- gsub("IPEC-ExIBOPE","IBOPE",
gsub("Ibope","IBOPE",d$Institute))#IPEC is former IBOPE
ds$Varname <-  gsub("\\s","",ds$Institute)
ds$Date <- ds$date
ds$Index <- ds$Positive
View(ds)
load("R/popularity_raw_BR.RData")
### The simple averaging approach ##################
ms <- my.averageM(d)  #by month
qs <- my.averageQ(d)  #by quarter
d$Institute <- gsub("IPEC-ExIBOPE","IBOPE",
gsub("Ibope","IBOPE",d$Institute))#IPEC is former IBOPE
d$Varname <-  gsub("\\s","",d$Institute)
d$Date <- d$date
d$Index <- d$Positive
View(d)
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(xtable)
library(Hmisc) # for Lag command
library(reshape)
library(plyr)
library(googlesheets4)
library(tidyverse)
rm(list = ls(all = TRUE))
source("R/Extract.r") #load stimsons "extract" function (downloaded from internet)
observations <- wcalcdiagnosticsQ <-  wcalcdiagnosticsM <- list()
my.drop <- function(xx){
xx$drop.wcalcM <- xx$drop.wcalcQ <-  F  #indicator for whether to drop
#Drop months after last obs and prior to first obs
for (i in levels(xx$PresidentS)){
firstmonth <- min(which(xx$PresidentS==i))
firstpop <- min(which(is.na(xx$Positive)==F&xx$PresidentS==i))
lastmonth <- max(which(xx$PresidentS==i))
lastpop <- max(which(is.na(xx$Positive)==F&xx$PresidentS==i))
if(firstmonth<firstpop){xx$drop.wcalcM[firstmonth:(firstpop-1)] <- T}
if(lastpop<lastmonth){xx$drop.wcalcM[(lastpop+1):lastmonth] <- T}
}
months.to.drop <- xx$M[xx$drop.wcalcM] #this is final
#For quarters, drop after last obs, prior to first obs and
#those with two presidents
Qpost <- unique(xx$Q[xx$drop.wcalcM]) #refine this later
tmp <- daply(xx,.(Q),function(x){sum(is.na(x$Positive))})
QNA <- names(tmp[tmp==3]) #quarters with no data
tmp <- daply(xx,.(Q),function(x){length(unique(x$PresidentS[is.na(x$Positive)==F]))})
Q2P <- names(tmp[tmp==2]) #quarters With DATA from two presidents
quarters.do.drop <- union(intersect(Qpost,QNA),Q2P)
#out <- list(M=months.to.drop,Q=quarters.do.drop)
xx$drop.wcalcQ[is.element(xx$Q,quarters.do.drop)] <- T
## The line below might seem strange, but it doesn't make sense to keep
## monthly observations of Q for months that have been dropped
## this is specially a problem for transition between presidents
xx$drop.wcalcQ[is.element(xx$M,months.to.drop)] <- T
cat('Should drop WCALC estimates for the following months:\n')
print(months.to.drop)
cat('and quarters:\n')
print(quarters.do.drop)
return(xx)
}
obsM <- function(d){nrow(d)}
institutesM <- function(d){length(unique(d$Institute))}
instituteM <- function(d){if(length(unique(d$Institute))==1){
as.character(d$Institute[1])}else{"_Multiple"}}
my.averageM <- function(x,drop.series=NULL){
if(is.null(drop.series)==F){	x <- subset(x,Institute!=drop.series)}
tmp <- ddply(x, "M", c("popM","obsM","institutesM"))
tmp2 <- ddply(x, "M", c("instituteM","presUsed"))
out <- merge(tmp,tmp2,by="M",all=T)
return(out)
}
popM <- function(d){#simple aggregation
ifelse(is.nan(mean(d$Positive,na.rm=T)),NA,mean(d$Positive,na.rm=T))}
popM <- function(x){#for when there is more than one president in the same term
if(length(unique(x$PresidentS))==1){
ifelse(is.nan(mean(x$Positive,na.rm=T)),NA,mean(x$Positive,na.rm=T))
}else{#if more than one president, use incoming
to.keep <- which(x$PresidentS==x$PresidentS[nrow(x)])
ifelse(is.nan(mean(x$Positive[to.keep],na.rm=T)),NA,mean(x$Positive[to.keep],na.rm=T))
}}
presUsed <- function(d){if(length(unique(d$PresidentS))==1){#use incoming president
as.character(d$PresidentS[1])}else{as.character(d$PresidentS[nrow(d)])}}
dateUsed <- function(d){ #if no observation, use start of quarter,
if(is.na(max(d$date))){
out <- gsub("-1","-02-15",d$Q)
out <- gsub("-2","-05-15",out)
out <- gsub("-3","-08-15",out)
out <- gsub("-4","-11-15",out)
}else{
out <- max(d$date)
}
return(out)}
dateUsed <- function(d){max(d$date)}
my.averageQ <- function(x,drop.series=NULL){
if(is.null(drop.series)==F){	x <- subset(x,Institute!=drop.series)}
tmp <- ddply(x, "Q", c("popM",
"obsM","institutesM"))
tmp2 <- ddply(x, "Q", c("instituteM","presUsed"))
tmp3 <- ddply(x, "Q", c("dateUsed"))
out <- merge(merge(tmp,tmp2,by="Q",all=T),tmp3,by="Q",all=T)
names(out)<-gsub("M","Q",names(out))
return(out)
}
#### Merge estimates into d dataset for plotting ####
Ms <- expand.grid(1980:2017,sprintf("%02.0f", 1:12))
Ms <- sort(paste(Ms[,1],Ms[,2],sep="-"))
Qs <- gsub("-01|-02|-03","-1"
,gsub("-04|-05|-06","-2"
,gsub("-07|-08|-09","-3"
,gsub("-10|-11|-12","-4",Ms))))
MQ <- data.frame(M=Ms,Q=Qs)
m1 <- 365/12
#Importing raw data
d <- read_csv("DATA/Popularity-LatinAmerica-BR.csv")
#Or read from saved as windows csv, so read with latin1. If saving as (mac) csv, read with macroman
#d<-read.csv(paste("./DATA/_popularity_BR_25mar21.csv",sep=""),
#            fileEncoding="latin1",na.strings = ".")
dd <- subset(d, President != "Figueiredo")
Nall <- nrow(dd)
#Get rid of spaces in pollster names
d$Institute <- gsub("\\s","\\.",d$Institute,perl=T)
#Use short presidential names, and rder factors cronologically
d$PresidentS <- factor(toupper(d$President),levels=c("FIGUEIREDO","SARNEY","COLLOR",
"FRANCO","CARDOSO","LULA","DILMA"
,"TEMER","BOLSONARO"))
#Check for missing data in relevant vars
tmp <- apply(is.na(subset(d,select=c(raw.date,President,PresidentS,Positive,Institute))),2,sum)
if(sum(tmp)>0){cat("Attention! Data missing in source\n");print(tmp)}
#Fix dates #
#Always a problem in Xls/csv
d$day[which(is.na(d$day))]<-15
d$month <- gsub("ago","aug",d$month)
d$month <- gsub("mai","may",d$month)
d$date <- as.Date(paste(d$year,d$month,d$day,sep="-"),format="%Y-%b-%d")
d$month <- d$day <-  NULL
d<-d[sort(as.character(d$date),index.return=TRUE)$ix,] #sort by date
d$Q <- paste(substr(d$date,1,5),quarters(d$date),sep="") #quarter indicator
d$Q <- gsub("Q","",d$Q)
d$M <- substr(d$date,1,7)#month indicator
d$raw.date <- NULL
save(d, file="R/popularity_raw_BR.RData")
#fork: save Bolsonaro's popularity separately
dd <- subset(d,President=="Bolsonaro"&year>=2019)
save(dd,file="R/popularity_raw_bolsonaro_BR.RData")
View(d)
Qpost
tmp
knitr::opts_chunk$set(echo = TRUE)
#Importing raw data
d <- read_csv("DATA/Popularity-LatinAmerica-BR.csv")
library(tidyverse)
knitr::opts_chunk$set(echo = TRUE)
#Importing raw data
d <- read_csv("DATA/Popularity-LatinAmerica-BR.csv")
#Or read from saved as windows csv, so read with latin1. If saving as (mac) csv, read with macroman
#d<-read.csv(paste("./DATA/_popularity_BR_25mar21.csv",sep=""),
#            fileEncoding="latin1",na.strings = ".")
dd <- subset(d, President != "Figueiredo")
Nall <- nrow(dd)
#Get rid of spaces in pollster names
d$Institute <- gsub("\\s","\\.",d$Institute,perl=T)
#Use short presidential names, and rder factors cronologically
d$PresidentS <- factor(toupper(d$President),levels=c("FIGUEIREDO","SARNEY","COLLOR",
"FRANCO","CARDOSO","LULA","DILMA"
,"TEMER","BOLSONARO"))
#Adjust IBOPE (IPEC is former IBOPE)
d$Institute <- gsub("IPEC-ExIBOPE","IBOPE",
gsub("Ibope","IBOPE",d$Institute))
#Check for missing data in relevant vars
tmp <- apply(is.na(subset(d,select=c(raw.date,President,PresidentS,Positive,Institute))),2,sum)
if(sum(tmp)>0){cat("Attention! Data missing in source\n");print(tmp)}
#Fix dates #
#Always a problem in Xls/csv
d$day[which(is.na(d$day))]<-15
d$month <- gsub("ago","aug",d$month)
d$month <- gsub("mai","may",d$month)
d$date <- as.Date(paste(d$year,d$month,d$day,sep="-"),format="%Y-%b-%d")
d$month <- d$day <-  NULL
d<-d[sort(as.character(d$date),index.return=TRUE)$ix,] #sort by date
d$Q <- paste(substr(d$date,1,5),quarters(d$date),sep="") #quarter indicator
d$Q <- gsub("Q","",d$Q)
d$M <- substr(d$date,1,7)#month indicator
d$raw.date <- NULL
save(d, file="R/popularity_raw_BR.RData")
#fork: save Bolsonaro's popularity separately
dd <- subset(d,President=="Bolsonaro"&year>=2019)
save(dd,file="R/popularity_raw_bolsonaro_BR.RData")
View(d)
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(xtable)
library(Hmisc) # for Lag command
library(reshape)
library(plyr)
library(googlesheets4)
library(tidyverse)
rm(list = ls(all = TRUE))
source("R/Extract.r") #load stimsons "extract" function (downloaded from internet)
observations <- wcalcdiagnosticsQ <-  wcalcdiagnosticsM <- list()
my.drop <- function(xx){
xx$drop.wcalcM <- xx$drop.wcalcQ <-  F  #indicator for whether to drop
#Drop months after last obs and prior to first obs
for (i in levels(xx$PresidentS)){
firstmonth <- min(which(xx$PresidentS==i))
firstpop <- min(which(is.na(xx$Positive)==F&xx$PresidentS==i))
lastmonth <- max(which(xx$PresidentS==i))
lastpop <- max(which(is.na(xx$Positive)==F&xx$PresidentS==i))
if(firstmonth<firstpop){xx$drop.wcalcM[firstmonth:(firstpop-1)] <- T}
if(lastpop<lastmonth){xx$drop.wcalcM[(lastpop+1):lastmonth] <- T}
}
months.to.drop <- xx$M[xx$drop.wcalcM] #this is final
#For quarters, drop after last obs, prior to first obs and
#those with two presidents
Qpost <- unique(xx$Q[xx$drop.wcalcM]) #refine this later
tmp <- daply(xx,.(Q),function(x){sum(is.na(x$Positive))})
QNA <- names(tmp[tmp==3]) #quarters with no data
tmp <- daply(xx,.(Q),function(x){length(unique(x$PresidentS[is.na(x$Positive)==F]))})
Q2P <- names(tmp[tmp==2]) #quarters With DATA from two presidents
quarters.do.drop <- union(intersect(Qpost,QNA),Q2P)
#out <- list(M=months.to.drop,Q=quarters.do.drop)
xx$drop.wcalcQ[is.element(xx$Q,quarters.do.drop)] <- T
## The line below might seem strange, but it doesn't make sense to keep
## monthly observations of Q for months that have been dropped
## this is specially a problem for transition between presidents
xx$drop.wcalcQ[is.element(xx$M,months.to.drop)] <- T
cat('Should drop WCALC estimates for the following months:\n')
print(months.to.drop)
cat('and quarters:\n')
print(quarters.do.drop)
return(xx)
}
obsM <- function(d){nrow(d)}
institutesM <- function(d){length(unique(d$Institute))}
instituteM <- function(d){if(length(unique(d$Institute))==1){
as.character(d$Institute[1])}else{"_Multiple"}}
my.averageM <- function(x,drop.series=NULL){
if(is.null(drop.series)==F){	x <- subset(x,Institute!=drop.series)}
tmp <- ddply(x, "M", c("popM","obsM","institutesM"))
tmp2 <- ddply(x, "M", c("instituteM","presUsed"))
out <- merge(tmp,tmp2,by="M",all=T)
return(out)
}
popM <- function(d){#simple aggregation
ifelse(is.nan(mean(d$Positive,na.rm=T)),NA,mean(d$Positive,na.rm=T))}
popM <- function(x){#for when there is more than one president in the same term
if(length(unique(x$PresidentS))==1){
ifelse(is.nan(mean(x$Positive,na.rm=T)),NA,mean(x$Positive,na.rm=T))
}else{#if more than one president, use incoming
to.keep <- which(x$PresidentS==x$PresidentS[nrow(x)])
ifelse(is.nan(mean(x$Positive[to.keep],na.rm=T)),NA,mean(x$Positive[to.keep],na.rm=T))
}}
presUsed <- function(d){if(length(unique(d$PresidentS))==1){#use incoming president
as.character(d$PresidentS[1])}else{as.character(d$PresidentS[nrow(d)])}}
dateUsed <- function(d){ #if no observation, use start of quarter,
if(is.na(max(d$date))){
out <- gsub("-1","-02-15",d$Q)
out <- gsub("-2","-05-15",out)
out <- gsub("-3","-08-15",out)
out <- gsub("-4","-11-15",out)
}else{
out <- max(d$date)
}
return(out)}
dateUsed <- function(d){max(d$date)}
my.averageQ <- function(x,drop.series=NULL){
if(is.null(drop.series)==F){	x <- subset(x,Institute!=drop.series)}
tmp <- ddply(x, "Q", c("popM",
"obsM","institutesM"))
tmp2 <- ddply(x, "Q", c("instituteM","presUsed"))
tmp3 <- ddply(x, "Q", c("dateUsed"))
out <- merge(merge(tmp,tmp2,by="Q",all=T),tmp3,by="Q",all=T)
names(out)<-gsub("M","Q",names(out))
return(out)
}
#### Merge estimates into d dataset for plotting ####
Ms <- expand.grid(1980:2017,sprintf("%02.0f", 1:12))
Ms <- sort(paste(Ms[,1],Ms[,2],sep="-"))
Qs <- gsub("-01|-02|-03","-1"
,gsub("-04|-05|-06","-2"
,gsub("-07|-08|-09","-3"
,gsub("-10|-11|-12","-4",Ms))))
MQ <- data.frame(M=Ms,Q=Qs)
m1 <- 365/12
View(MQ)
m1 <- 365/12
useQ
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse) #1
rm(list = ls(all = TRUE))
#Importing raw data
d <- read_csv("DATA/Popularity-LatinAmerica-BR.csv")
#Or read from saved as windows csv, so read with latin1. If saving as (mac) csv,
# read with macroman
#d <-read.csv(paste("./DATA/_popularity_BR_25mar21.csv",sep=""),
#            fileEncoding="latin1",na.strings = ".")
dd <- subset(d, President != "Figueiredo")
Nall <- nrow(dd)
#Get rid of spaces in pollster names
d$Institute <- gsub("\\s","\\.",d$Institute,perl=T)
#Use short presidential names, and rder factors cronologically
d$PresidentS <- factor(toupper(d$President),levels=c("FIGUEIREDO","SARNEY","COLLOR",
"FRANCO","CARDOSO","LULA","DILMA"
,"TEMER","BOLSONARO"))
#Adjust IBOPE (IPEC is former IBOPE)
d$Institute <- gsub("IPEC-ExIBOPE","IBOPE",
gsub("Ibope","IBOPE",d$Institute))
#Check for missing data in relevant vars
tmp <- apply(is.na(subset(d,select=c(raw.date,President,PresidentS,Positive,Institute))),
2,sum)
if(sum(tmp)>0){cat("Attention! Data missing in source\n");print(tmp)}
#Fix dates #
#Always a problem in Xls/csv
d$day[which(is.na(d$day))]<-15
d$month <- gsub("ago","aug",d$month)
d$month <- gsub("mai","may",d$month)
d$date <- as.Date(paste(d$year,d$month,d$day,sep="-"),format="%Y-%b-%d")
d$month <- d$day <-  NULL
d<-d[sort(as.character(d$date),index.return=TRUE)$ix,] #sort by date
d$Q <- paste(substr(d$date,1,5),quarters(d$date),sep="") #quarter indicator
d$Q <- gsub("Q","",d$Q)
d$M <- substr(d$date,1,7)#month indicator
d$raw.date <- NULL
save(d, file="R/popularity_raw_BR.RData")
#fork: save Bolsonaro's popularity separately
dd <- subset(d,President=="Bolsonaro"&year>=2019)
save(dd,file="R/popularity_raw_bolsonaro_BR.RData")
d <- load("R/popularity_raw_BR.RData")
d <- load("R/popularity_raw_BR.RData")
load("R/popularity_raw_BR.RData")
load("R/popularity_raw_BR.RData")
load("R/popularity_raw_bolsonaro_BR.RData")
par(mar=c(2.5,5.5,.5,.5))
min.y<-0
max.y<-100
plot(d$date, d$Positive,type="n"
,ylab="Approval or Popularity"
,xlab="",bty="n",
cex.axis=1.2,cex.lab=1.2,ylim=c(min.y,max.y))
polygon(x=c(min(d$date),pres.dates[1],pres.dates[1],min(d$date)),
y=c(min.y,min.y,max.y,max.y),border=NA,col=gray(0.9))
Nall <- nrow(dd)
pres.dates <- c(
as.Date(c(
"1979-03-15",#start of Figueiredo, prior to start of data
"1985-03-15",#start of Sarney
"1990-03-15",#start of collor
"1992-10-02",#start of Franco
"1995-01-01",#start of FHC
"2003-01-01",#start of Lula
"2011-01-01",#start of Dilma
"2016-08-31",#start of Temer
"2019-01-01"#start of Bolsonaro
)),Sys.Date())
par(mar=c(2.5,5.5,.5,.5))
min.y<-0
max.y<-100
plot(d$date, d$Positive,type="n"
,ylab="Approval or Popularity"
,xlab="",bty="n",
cex.axis=1.2,cex.lab=1.2,ylim=c(min.y,max.y))
polygon(x=c(min(d$date),pres.dates[1],pres.dates[1],min(d$date)),
y=c(min.y,min.y,max.y,max.y),border=NA,col=gray(0.9))
for(i in seq(2,length(pres.dates),by=2)){
polygon(x=c(pres.dates[i],pres.dates[i+1],pres.dates[i+1],pres.dates[i]),
y=c(min.y,min.y,max.y,max.y),border=NA,col=gray(0.9))	}
points(d$date,d$popM,pch=".",cex=2)
alt <- -1
for(i in levels(d$PresidentS)){
text(mean(d$date[d$PresidentS==i],na.rm=T),max.y-2,labels=i,cex=0.6,pos=2+alt)
lines(d$date[which(d$PresidentS==i)],d$latentM[which(d$PresidentS==i)],col=gray(0))
lines(d$date[which(d$PresidentS==i)],d$popM.li[which(d$PresidentS==i)],col=1,lty=3)
alt <- alt * -1 #to alternate position of name
}
legend(x="bottomright"
,legend=c("Raw Data Point","Average (Monthly)","Latent Estimate (Monthly)",
"Latent Estimate (Quarterly)")
,cex=0.8
,lty=c(NA,3,1,1)
,col=c(1,gray(0),gray(0),gray(.5))
,pch=c(".",NA,NA,NA),pt.cex=4,bty="n")
#abline(h=33,lty=2)
abline(v=c(as.Date("1994-10-01"),
as.Date("1998-10-01"),
as.Date("2002-10-01"),
as.Date("2006-10-01"),
as.Date("2010-10-01"),
as.Date("2014-10-01"),
as.Date("2018-10-01")))
install.packages("googlesheets4")
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(xtable)
library(Hmisc) # for Lag command
library(reshape)
library(plyr)
library(googlesheets4)
library(tidyverse)
rm(list = ls(all = TRUE))
d <- read_sheet("https://docs.google.com/spreadsheets/d/1c9TIhlOhUUpRCDKeVv7mMzGNuM7YpyJ_2ffmv-bhHrE/edit#gid=1719683872")
d <- read_sheet("https://docs.google.com/spreadsheets/d/1c9TIhlOhUUpRCDKeVv7mMzGNuM7YpyJ_2ffmv-bhHrE/edit#gid=1719683872")
rlang::last_error()
